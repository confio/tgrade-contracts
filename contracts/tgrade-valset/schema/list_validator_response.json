{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ListValidatorResponse",
  "type": "object",
  "required": [
    "validators"
  ],
  "properties": {
    "validators": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/OperatorResponse"
      }
    }
  },
  "definitions": {
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
      "type": "string"
    },
    "Expiration": {
      "$ref": "#/definitions/Timestamp"
    },
    "JailingPeriod": {
      "anyOf": [
        {
          "type": "object",
          "required": [
            "Forever"
          ],
          "properties": {
            "Forever": {
              "type": "object"
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "Until"
          ],
          "properties": {
            "Until": {
              "$ref": "#/definitions/Expiration"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "OperatorResponse": {
      "type": "object",
      "required": [
        "metadata",
        "operator",
        "pubkey"
      ],
      "properties": {
        "jailed_until": {
          "anyOf": [
            {
              "$ref": "#/definitions/JailingPeriod"
            },
            {
              "type": "null"
            }
          ]
        },
        "metadata": {
          "$ref": "#/definitions/ValidatorMetadata"
        },
        "operator": {
          "type": "string"
        },
        "pubkey": {
          "$ref": "#/definitions/Pubkey"
        }
      }
    },
    "Pubkey": {
      "description": "A Tendermint validator pubkey.\n\nSee https://github.com/tendermint/tendermint/blob/master/proto/tendermint/crypto/keys.proto for a list of available types. Sr25519 is added here as it is likely to join the party.\n\nThis type is optimized for the JSON interface. No data validation on the enum cases is performed. If you don't trust the data source, you can create a `ValidatedPubkey` enum that mirrors this type and uses fixed sized data fields.",
      "anyOf": [
        {
          "description": "32 bytes Ed25519 pubkey",
          "type": "object",
          "required": [
            "ed25519"
          ],
          "properties": {
            "ed25519": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Must use 33 bytes 0x02/0x03 prefixed compressed pubkey format",
          "type": "object",
          "required": [
            "secp256k1"
          ],
          "properties": {
            "secp256k1": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "32 bytes Sr25519 pubkey",
          "type": "object",
          "required": [
            "sr25519"
          ],
          "properties": {
            "sr25519": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Timestamp": {
      "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
      "allOf": [
        {
          "$ref": "#/definitions/Uint64"
        }
      ]
    },
    "Uint64": {
      "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
      "type": "string"
    },
    "ValidatorMetadata": {
      "description": "Validator Metadata modeled after the Cosmos SDK staking module",
      "type": "object",
      "required": [
        "moniker"
      ],
      "properties": {
        "details": {
          "description": "The validator's (optional) details",
          "type": [
            "string",
            "null"
          ]
        },
        "identity": {
          "description": "The optional identity signature (ex. UPort or Keybase)",
          "type": [
            "string",
            "null"
          ]
        },
        "moniker": {
          "description": "The validator's name (required)",
          "type": "string"
        },
        "security_contact": {
          "description": "The validator's (optional) security contact email",
          "type": [
            "string",
            "null"
          ]
        },
        "website": {
          "description": "The validator's (optional) website",
          "type": [
            "string",
            "null"
          ]
        }
      }
    }
  }
}
