{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "InstantiateMsg",
  "type": "object",
  "required": [
    "epoch_length",
    "epoch_reward",
    "initial_keys",
    "max_validators",
    "membership",
    "min_weight"
  ],
  "properties": {
    "admin": {
      "description": "Address allowed to jail, meant to be a OC voting contract. If `None`, then jailing is impossible in this contract.",
      "type": [
        "string",
        "null"
      ]
    },
    "auto_unjail": {
      "description": "Flag determining if validators should be automatically unjailed after jailing period, false by default.",
      "default": false,
      "type": "boolean"
    },
    "distribution_contract": {
      "description": "Address where part of reward for non-validators is send for further distribution. It is required to handle `distribute {}` message (eg. tg4-engagement contract) which would distribute funds send with this message. If no account is provided, `validators_reward_ratio` has to be `1`.",
      "type": [
        "string",
        "null"
      ]
    },
    "epoch_length": {
      "description": "Number of seconds in one epoch. We update the Tendermint validator set only once per epoch. Epoch # is env.block.time/epoch_length (round down). First block with a new epoch number will trigger a new validator calculation.",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "epoch_reward": {
      "description": "Total reward paid out each epoch. This will be split among all validators during the last epoch. (epoch_reward.amount * 86_400 * 30 / epoch_length) is reward tokens to mint each month. Ensure this is sensible in relation to the total token supply.",
      "allOf": [
        {
          "$ref": "#/definitions/Coin"
        }
      ]
    },
    "fee_percentage": {
      "description": "Percentage of total accumulated fees which is substracted from tokens minted as a rewards. 50% as default. To disable this feature just set it to 0 (which efectivelly means that fees doesn't affect the per epoch reward).",
      "default": "0",
      "allOf": [
        {
          "$ref": "#/definitions/Decimal"
        }
      ]
    },
    "initial_keys": {
      "description": "Initial operators and validator keys registered. If you do not set this, the validators need to register themselves before making this privileged/calling the EndBlockers, so we have a non-empty validator set",
      "type": "array",
      "items": {
        "$ref": "#/definitions/OperatorInitInfo"
      }
    },
    "max_validators": {
      "description": "The maximum number of validators that can be included in the Tendermint validator set. If there are more validators than slots, we select the top N by membership weight descending. (In case of ties at the last slot, select by \"first\" tendermint pubkey lexicographically sorted).",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0
    },
    "membership": {
      "description": "address of a cw4 contract with the raw membership used to feed the validator set",
      "type": "string"
    },
    "min_weight": {
      "description": "minimum weight needed by an address in `membership` to be considered for the validator set. 0-weight members are always filtered out. TODO: if we allow sub-1 scaling factors, determine if this is pre-/post- scaling (use weight for cw4, power for tendermint)",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "scaling": {
      "description": "A scaling factor to multiply cw4-group weights to produce the tendermint validator power (TODO: should we allow this to reduce weight? Like 1/1000?)",
      "type": [
        "integer",
        "null"
      ],
      "format": "uint32",
      "minimum": 0.0
    },
    "validators_reward_ratio": {
      "description": "Fraction of how much reward is distributed between validators. Remainder is send to the `distribution_contract` with `Distribute` message, which should perform distribution of send funds between non-validator basing on their engagement. This value is in range of `[0-1]`, `1` (or `100%`) by default.",
      "default": "1",
      "allOf": [
        {
          "$ref": "#/definitions/Decimal"
        }
      ]
    }
  },
  "definitions": {
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>",
      "type": "string"
    },
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "Decimal": {
      "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
      "type": "string"
    },
    "OperatorInitInfo": {
      "description": "Maps an sdk address to a Tendermint pubkey.",
      "type": "object",
      "required": [
        "metadata",
        "operator",
        "validator_pubkey"
      ],
      "properties": {
        "metadata": {
          "$ref": "#/definitions/ValidatorMetadata"
        },
        "operator": {
          "type": "string"
        },
        "validator_pubkey": {
          "description": "TODO: better name to specify this is the Tendermint pubkey for consensus?",
          "allOf": [
            {
              "$ref": "#/definitions/Pubkey"
            }
          ]
        }
      }
    },
    "Pubkey": {
      "description": "A Tendermint validator pubkey.\n\nSee https://github.com/tendermint/tendermint/blob/master/proto/tendermint/crypto/keys.proto for a list of available types. Sr25519 is added here as it is likely to join the party.\n\nThis type is optimized for the JSON interface. No data validation on the enum cases is performed. If you don't trust the data source, you can create a `ValidatedPubkey` enum that mirrors this type and uses fixed sized data fields.",
      "oneOf": [
        {
          "description": "32 bytes Ed25519 pubkey",
          "type": "object",
          "required": [
            "ed25519"
          ],
          "properties": {
            "ed25519": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Must use 33 bytes 0x02/0x03 prefixed compressed pubkey format",
          "type": "object",
          "required": [
            "secp256k1"
          ],
          "properties": {
            "secp256k1": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "32 bytes Sr25519 pubkey",
          "type": "object",
          "required": [
            "sr25519"
          ],
          "properties": {
            "sr25519": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "ValidatorMetadata": {
      "description": "Validator Metadata modeled after the Cosmos SDK staking module",
      "type": "object",
      "required": [
        "moniker"
      ],
      "properties": {
        "details": {
          "description": "The validator's (optional) details",
          "type": [
            "string",
            "null"
          ]
        },
        "identity": {
          "description": "The optional identity signature (ex. UPort or Keybase)",
          "type": [
            "string",
            "null"
          ]
        },
        "moniker": {
          "description": "The validator's name (required)",
          "type": "string"
        },
        "security_contact": {
          "description": "The validator's (optional) security contact email",
          "type": [
            "string",
            "null"
          ]
        },
        "website": {
          "description": "The validator's (optional) website",
          "type": [
            "string",
            "null"
          ]
        }
      }
    }
  }
}
